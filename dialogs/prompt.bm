'FTP Client
'Copyright Matt Kilgore -- 2011/2013

'This program is free software, without any warranty of any kind.
'You are free to edit, copy, modify, and redistribute it under the terms
'of the Do What You Want Public License, Version 1, as published by Matt Kilgore
'See file COPYING that should have been included with this source.
FUNCTION prompt_dialog (dialog$, tim, buttons, default)
'dialog$ will be printed above choices. If dialog$ contains CHR$(13), each one represents a new line
'tim is seconds still close
'if tim is reached, then default is returned
gui_num = 1
IF buttons AND OK_BUTTON THEN gui_num = gui_num + 1
IF buttons AND NO_BUTTON THEN gui_num = gui_num + 1
IF buttons AND CLOSE_BUTTON THEN gui_num = gui_num + 1
IF buttons AND CANCEL_BUTTON THEN gui_num = gui_num + 1
IF buttons AND YES_BUTTON THEN gui_num = gui_num + 1
button_count = gui_num - 1

IF INSTR(dialog$, CHR$(13)) THEN
  rows_add = 0
  k$ = dialog$
  DO
    rows_add = rows_add + 1
    k$ = MID$(k$, INSTR((k$), CHR$(13)) + 1)
  LOOP UNTIL INSTR(k$, CHR$(13)) = 0
  rows_add = rows_add + 1
ELSE
  rows_add = 1
END IF

gui_num = gui_num + rows_add

DIM rows$(rows_add)
IF INSTR(dialog$, CHR$(13)) THEN
  k$ = dialog$
  FOR x = 1 TO rows_add - 1
    rows$(x) = MID$(k$, 1, INSTR(k$, CHR$(13)) - 1)
    k$ = MID$(k$, INSTR(k$, CHR$(13)) + 1)
    IF LEN(rows$(x)) > box_width THEN box_width = LEN(rows$(x))
  NEXT x
  rows$(rows_add) = k$
  IF LEN(rows$(rows_add)) > box_width THEN box_width = LEN(rows$(rows_add))
ELSE
  rows$(1) = dialog$
  box_width = LEN(rows$(1))
END IF
box_width = box_width + 4

IF box_width < 40 THEN box_width = 40

if tim > 0 then gui_num = gui_num + 1

DIM gui(gui_num) AS GUI_element_type, labels(rows_add), tim_label, buttons(button_count)

gui(1).element_type = GUI_BOX
gui(1).dialog = -1
GUI_init_element gui(1), ""
gui(1).row1 = _HEIGHT(0) / 2 - 2
gui(1).row2 = gui(1).row1 + 3 + rows_add
IF tim > 0 THEN gui(1).row2 = gui(1).row2 + 1
gui(1).col1 = _WIDTH(0) / 2 - box_width \ 2
gui(1).col2 = gui(1).col1 + box_width
gui(1).shadow = -1
gui(1).skip = -1
gui(1).layer = -1

for x = 1 to rows_add
  gui(x + 1).element_type = GUI_LABEL
  gui(x + 1).dialog = -1
  GUI_init_element gui(x + 1), rows$(x)
  gui(x + 1).row1 = gui(1).row1 + x
  gui(x + 1).col1 = gui(1).col1 + (gui(1).col2 - gui(1).col1) \ 2 - (len(rows$(x))) \ 2
  labels(x) = x + 1
next x

button_start = rows_add + 1
if tim > 0 then
  tim_label = 2 + rows_add
  gui(tim_label).element_type = GUI_LABEL
  gui(tim_label).dialog = -1
  GUI_init_element gui(tim_label), ""
  gui(tim_label).row1 = gui(1).row1 + rows_add + 1
  gui(tim_label).col1 = 1
  button_start = button_start + 1
end if

FOR x = 1 TO button_count
  n = button_start + x
  gui(n).element_type = GUI_BUTTON
  gui(n).dialog = -1
  gui(n).row1 = gui(1).row2 - 1
  gui(n).col1 = gui(1).col1 + ((gui(1).col2 - gui(1).col1) / (button_count + 1)) * x
  IF NOT ok_flag AND (buttons AND OK_BUTTON) THEN
    ok_flag = -1
    GUI_init_element gui(n), "OK"
    gui(n).col1 = gui(n).col1 - 2
  ELSEIF NOT cancel_flag AND (buttons AND CANCEL_BUTTON) THEN
    cancel_flag = -1
    GUI_init_element gui(n), "CANCEL"
    gui(n).col1 = gui(n).col1 - 4
  ELSEIF NOT yes_flag AND (buttons AND YES_BUTTON) THEN
    yes_flag = -1
    GUI_init_element gui(n), "YES"
    gui(n).col1 = gui(n).col1 - 2
  ELSEIF NOT no_flag AND (buttons AND NO_BUTTON) THEN
    no_flag = -1
    GUI_init_element gui(n), "NO"
    gui(n).col1 = gui(n).col1 - 2
  ELSEIF NOT close_flag AND (buttons AND CLOSE_BUTTON) THEN
    close_flag = -1
    GUI_init_element gui(n), "CLOSE"
    gui(n).col1 = gui(n).col1 - 3
  END IF
  buttons(x) = n
NEXT x

t# = TIMER
t_count = tim
selected_gui = 1
DO
  _LIMIT 100
  
  if GUI_update_screen(gui(), gui_num, selected_gui) then
    GUI_draw_element_array gui(), gui_num, selected_gui
  end if
  
  GUI_mouse_range gui(), gui_num, selected_gui
  
  a$ = GUI_inkey$(gui(), gui_num, selected_gui)
  
  select case a$
    case chr$(27)
      esc_flag = -1
      exit_flag = -1
  end select

  for x = 1 to button_count
    if gui(buttons(x)).pressed then
      exit_flag = -1
    end if
  next x

  IF t_count > 0 and TIMER - t# > 1 THEN
    t_count = t_count - 1
    s$ = "Dialog will close in" + STR$(t_count) + " seconds..."
    MEM_put_str gui(tim_label).nam, s$
    gui(tim_label).col1 = _WIDTH(0) \ 2 - len(s$) \ 2
    gui(tim_label).updated = -1
    t# = TIMER
  end if
  
LOOP UNTIL exit_flag OR (t_count = 0 and tim > 0)

IF (t_count > 0 AND tim > 0) or esc_flag THEN
  prompt_dialog = default
ELSEIF MEM_get_str$(gui(selected_gui).nam) = "OK" THEN
  prompt_dialog = OK_BUTTON
ELSEIF MEM_get_str$(gui(selected_gui).nam) = "CLOSE" THEN
  prompt_dialog = CLOSE_BUTTON
ELSEIF MEM_get_str$(gui(selected_gui).nam) = "CANCEL" THEN
  prompt_dialog = CANCEL_BUTTON
ELSEIF MEM_get_str$(gui(selected_gui).nam) = "NO" THEN
  prompt_dialog = NO_BUTTON
ELSEIF MEM_get_str$(gui(selected_gui).nam) = "YES" THEN
  prompt_dialog = YES_BUTTON
END IF

GUI_free_element_array gui()
END FUNCTION
