'FTP Client
'Copyright Matt Kilgore -- 2011/2013

'This program is free software, without any warranty of any kind.
'You are free to edit, copy, modify, and redistribute it under the terms
'of the Do What You Want Public License, Version 1, as published by Matt Kilgore
'See file COPYING that should have been included with this source.
FUNCTION prompt_dialog (dialog$, tim, buttons, default)
'dialog$ will be printed above choices. If dialog$ contains CHR$(13), each one represents a new line
'tim is seconds still close
'if tim is reached, then default is returned
gui_num = 0
IF buttons AND OK_BUTTON THEN gui_num = gui_num + 1
IF buttons AND NO_BUTTON THEN gui_num = gui_num + 1
IF buttons AND CLOSE_BUTTON THEN gui_num = gui_num + 1
IF buttons AND CANCEL_BUTTON THEN gui_num = gui_num + 1
IF buttons AND YES_BUTTON THEN gui_num = gui_num + 1
DIM gui(gui_num) AS box_type, main_Box AS box_type
IF INSTR(dialog$, CHR$(13)) THEN
  rows_add = 0
  k$ = dialog$
  DO
    rows_add = rows_add + 1
    k$ = MID$(k$, INSTR((k$), CHR$(13)) + 1)
  LOOP UNTIL INSTR(k$, CHR$(13)) = 0
  rows_add = rows_add + 1
ELSE
  rows_add = 1
END IF

DIM rows$(rows_add)
IF INSTR(dialog$, CHR$(13)) THEN
  k$ = dialog$
  FOR x = 1 TO rows_add - 1
    rows$(x) = MID$(k$, 1, INSTR(k$, CHR$(13)) - 1)
    k$ = MID$(k$, INSTR(k$, CHR$(13)) + 1)
    IF LEN(rows$(x)) > box_width THEN box_width = LEN(rows$(x))
  NEXT x
  rows$(rows_add) = k$
  IF LEN(rows$(rows_add)) > box_width THEN box_width = LEN(rows$(rows_add))
ELSE
  rows$(1) = dialog$
  box_width = LEN(rows$(1))
END IF
box_width = box_width + 4

IF box_width < 40 THEN box_width = 40

'main_Box.nam = ""
put_str main_Box.nam, ""
main_Box.text_box = -1
main_Box.c1 = box_c1
main_Box.c2 = box_c2
main_Box.row1 = _HEIGHT(0) / 2 - 2
main_Box.row2 = main_Box.row1 + 3 + rows_add
IF tim > 0 THEN main_Box.row2 = main_Box.row2 + 1
main_Box.col1 = _WIDTH(0) / 2 - box_width \ 2
main_Box.col2 = main_Box.col1 + box_width
main_Box.shadow = -1

FOR x = 1 TO gui_num
  gui(x).button = -1
  gui(x).c1 = box_c1
  gui(x).c2 = box_c2
  gui(x).sc1 = box_sel_c1
  gui(x).sc2 = box_sel_c2
  gui(x).row1 = main_Box.row2 - 1
  gui(x).col1 = main_Box.col1 + ((main_Box.col2 - main_Box.col1) / (gui_num + 1)) * x
  IF NOT ok_flag AND (buttons AND OK_BUTTON) THEN
    ok_flag = -1
    'gui(x).nam = "OK"
    put_str gui(x).nam, "OK"
    gui(x).col1 = gui(x).col1 - 2
  ELSEIF NOT cancel_flag AND (buttons AND CANCEL_BUTTON) THEN
    cancel_flag = -1
    ' gui(x).nam = "CANCEL"
    put_str gui(x).nam, "CANCEL"
    gui(x).col1 = gui(x).col1 - 4
  ELSEIF NOT yes_flag AND (buttons AND YES_BUTTON) THEN
    yes_flag = -1
    ' gui(x).nam = "YES"
    put_str gui(x).nam, "YES"
    gui(x).col1 = gui(x).col1 - 2
  ELSEIF NOT no_flag AND (buttons AND NO_BUTTON) THEN
    no_flag = -1
    ' gui(x).nam = "NO"
    put_str gui(x).nam, "NO"
    gui(x).col1 = gui(x).col1 - 2
  ELSEIF NOT close_flag AND (buttons AND CLOSE_BUTTON) THEN
    close_flag = -1
    ' gui(x).nam = "CLOSE"
    put_str gui(x).nam, "CLOSE"
    gui(x).col1 = gui(x).col1 - 3
  END IF
NEXT x

update = -1
curr = 1
curc = 1
t# = TIMER
DO
  _LIMIT 100
  m = mouse_range(gui(), gui_num)
  IF m > 0 THEN
    s_box = m
    update = -1
    exit_flag = -1
  END IF
  IF update THEN
    update = 0
    _DISPLAY
    draw_box main_Box, 0
    COLOR box_c1, box_c2
    FOR x = 1 TO rows_add
      LOCATE main_Box.row1 + x, main_Box.col1 + (main_Box.col2 - main_Box.col1) / 2 - LEN(rows$(x)) / 2
      PRINT rows$(x);
    NEXT x
    'PRINT dialog$; STR$(gui_num);
    IF tim > 0 THEN
      s$ = "Dialog will close in" + STR$(tim - INT(TIMER - t#)) + " seconds..."
      LOCATE main_Box.row1 + 1 + rows_add, main_Box.col1 + (main_Box.col2 - main_Box.col1) / 2 - LEN(s$) / 2
      PRINT s$;
      LOCATE main_Box.row1 + 2 + rows_add, main_Box.col1
    ELSE
      LOCATE main_Box.row1 + 1 + rows_add, main_Box.col1
    END IF
    PRINT CHR$(195); STRING$(main_Box.col2 - main_Box.col1 - 1, 196); CHR$(180);
    FOR x = 1 TO gui_num
      draw_box gui(x), s_box = x
      IF s_box = x THEN
        curr = gui(x).row1
        curc = gui(x).col1 + 1
      END IF
    NEXT x
    _AUTODISPLAY
    LOCATE curr, curc, 1
  END IF
  a$ = INKEY$
  SELECT CASE a$
    CASE CHR$(9)
      s_box = (s_box MOD gui_num) + 1
      update = -1
    CASE CHR$(13)
      exit_flag = -1
    CASE CHR$(0) + CHR$(72), CHR$(0) + CHR$(80), CHR$(0) + CHR$(75), CHR$(0) + CHR$(77)
      new_gui = move_to_next_gui(a$, s_box, gui(), gui_num)
      IF new_gui > -1 THEN
        s_box = new_gui
        update = -1
      END IF
  END SELECT
  IF TIMER - t# > tsav THEN
    tsav = TIMER - t# + .2
    update = -1
  END IF
LOOP UNTIL exit_flag OR (TIMER - t# > tim AND tim > 0)
_DISPLAY
IF TIMER - t# > tim AND tim > 0 THEN
  prompt_dialog = default
ELSEIF get_str$(gui(s_box).nam) = "OK" THEN
  prompt_dialog = OK_BUTTON
ELSEIF get_str$(gui(s_box).nam) = "CLOSE" THEN
  prompt_dialog = CLOSE_BUTTON
ELSEIF get_str$(gui(s_box).nam) = "CANCEL" THEN
  prompt_dialog = CANCEL_BUTTON
ELSEIF get_str$(gui(s_box).nam) = "NO" THEN
  prompt_dialog = NO_BUTTON
ELSEIF get_str$(gui(s_box).nam) = "YES" THEN
  prompt_dialog = YES_BUTTON
END IF
LOCATE , , 0
free_gui_element main_box
free_gui_array gui()
END FUNCTION
